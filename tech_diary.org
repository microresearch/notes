* 30/6

** steghide: 

: steghide embed -cf testfan.wav -ef ~/Downloads/latoysondorovlaf00tris_0093.jpg

: steghide extract -sf testfan.wav

Spectrograms encoder: https://github.com/solusipse/spectrology

Lots: https://github.com/DominicBreuker/stego-toolkit

* 1/7

** no titlebars/.deco in awesome:

    -- Add titlebars to normal clients and dialogs
    { rule_any = {type = { "normal", "dialog" }
      }, properties = { titlebars_enabled = false }
    },

** how z80 actually starts up

When the CPU starts running (which basically happens as soon as it
receives power and is reset with the RESET pin), it begins to pull
instructions from memory and execute them. Where it starts in memory
depends on the individual CPU, but in the case of the Z80, it simply
begins at memory address 0, instead of using a reset vector like many
other CPUs do. This means that any computer using the Z80 *must* have
a ROM chip at memory address 0 which gives the initial start-up
instructions to the Z80.

from: http://lateblt.tripod.com/z80proj1.htm

https://maker.pro/pic/projects/z80-computer-project-part-1-the-cpu

http://bedroomcoders.co.uk/using-an-arduino-to-run-a-z80/

useful: http://baltazarstudios.com/arduino-zilog-z80/

http://labs.domipheus.com/blog/teensy-z80-part-1-intro-memory-serial-io-and-display/

test circuit: http://www.z80.info/z80test0.htm

https://github.com/inxonic/z80fun

https://github.com/Apress/junk-box-arduino/blob/master/9781484214268/Z80_Explorer_v2.1/Z80_Explorer_v2.1.ino

** or 6502 or...

see emulation: http://obsolescence.wixsite.com/obsolescence/kim-uno-details

* 2/7

** Kicad BOM:

Following: https://github.com/SchrodingersGat/KiBoM

** start on parts lists and spreadsheet

Bulk

Detektors

Darkint: /root/rsync2016/darkint/hardware/draft/partslist.org

ERDs:

Misc parts/projects:

* 4/7

settings for minicom from command line

: minicom -b 57600 -D /dev/ttyACM0

* 5/7

- these notes, also messene etc. under git DONE:

new repo in git

: git init
: git add whatever
: git commit -m "xxx"
: git remote add origin https://github.com/microresearch/notes.git
: git push -u origin master

- re-check AD5933 also for potential eurorack module
* 6/7

** admatech TFT display on pi:

https://raspberrypi.stackexchange.com/questions/38721/how-do-i-setup-the-c-berry-tft-screen-with-my-pi-2

and ignore row-defining changes...

for console - compile /C-Berry/SW/fb2cberry, run in background...1

: echo -ne "help" | sudo tee /dev/tty1

* 7/7

** splitscan and mencoder cut/edit

cutting using mencoder

: mencoder -ss 00:27:31 -endpos 00:00:37 -oac pcm -ovc copy Downloads/Princess.mp4 -o revolving.mp4

starts at 27.31 and lasts for 37 seconds

splitscan.py new code:

#+BEGIN_SRC python

# horizontal

# for i in clip.iter_frames(fps=target_fps, dtype='uint8'):
#     if currentX < (clip.size[0] - slitwidth):
#         img[:,currentX:currentX + slitwidth,:] = i[:,currentX:currentX + slitwidth,:]
#     currentX += slitwidth

# horizontal/backwards
count=0
currentX = clip.size[1]

for i in clip.iter_frames(fps=target_fps, dtype='uint8'):
    print count
    if currentX < (clip.size[0] - slitwidth):
        img[:,currentX:currentX + slitwidth,:] = i[:,currentX:currentX + slitwidth,:]
    currentX -= slitwidth
    count +=1

###vertical

# for i in clip.iter_frames(fps=target_fps, dtype='uint8'):
#     if currentX < (clip.size[1] - slitwidth):
#                 img[currentX:currentX + slitwidth,:] = i[currentX:currentX + slitwidth,:]
#     currentX += slitwidth

#+END_SRC

** video to images

: ffmpeg -i input.mov -r 1 output_%04d.png

with -r 1 as 1 frame every second

** images to video

: convert output_00* test.mp4

** others

: ffmpeg -i source.mp4 -filter:v minterpolate -r 120 result.mp4


** kill cursor to end of line Ctrl - k

: bindkey

shows key bindings

* 11/7

working with imagemagick:

http://www.imagemagick.org/Usage/layers/

http://www.imagemagick.org/Usage/transform/#edge

http://www.imagemagick.org/Usage/fonts/

* 12/7

awesome

mod-t = keep window always on top

kicad

- remember after we change cvpcb netlist to generate/save netlist in eeschema

* 13/7

** teensy

https://www.pjrc.com/teensy/loader_cli.html

code: https://github.com/PaulStoffregen/teensy_loader_cli.git

: ./teensy_loader_cli -mmcu=mk20dx256 -w blink_slow_Teensy32.hex 

for our teensy 3.2 and press reset...

+using avr-gcc/example makefile: https://www.pjrc.com/teensy/gcc.html+ - this is not for ARM teensy

or we try using ard-make (had to re-install latest: https://github.com/sudar/Arduino-Makefile and latest Arduino

blink teensy example worked but not another serial example

* 16/7

*For zx81 earthboot thing on teensy (emulated ROM with earthboot)*

https://k1.spdns.de/Vintage/Sinclair/80/Sinclair%20ZX81/ROMs/zx81%20version%202%20%27improved%27%20rom%20disassembly%20%28Logan,%20O%27Hara%29.html

https://www.sinclairzxworld.com/viewtopic.php?t=1249

CS goes low for ROM access and then high within maybe 300nS

MREQ and A14 line (inverted) go through NAND to CS for this...

: // when cs goes low we put the earth code (amped from diff amp 200x in earth)
: // onto D0-> D7

As ADC is slower than 3Mhz ROM/RAM we need to read it first into array and then output

Teensy Makefile: https://github.com/apmorton/teensy-template

But we needed to change the 

: TOOLSPATH=/root/Downloads/arduino-1.8.5/hardware/tools

as the tools included are compile for 64 bits...

pins: https://forum.pjrc.com/threads/17532-Tutorial-on-digital-I-O-ATMega-PIN-PORT-DDR-D-B-registers-vs-ARM-GPIO_PDIR-_PDOR?highlight=slew+rate+limiting
          
* 17/7

- display hack works - https://www.classic-computers.org.nz/blog/2016-01-03-composite-video-for-zx81.htm

- teensy is at 3.3v (no more) - some pins are not tolerant and maybe our level is low // revert to arduino/avr code  if it can be fast enough

- also after replacing ROM on zx no boot - loosen and reseat is fine (and wiggles generate glitches so...)

- code on arduino doesn't do anything (note that we would need to reboot arduino just before zx to allow buffer to fill):

-- problem could be: speed of arduino, check pins are toggling, check CS lines coming in and timing (scope)

(Notes: Uno has 2k so we just use 1024 bytes for earthcode, alt
approach could be to allow earthcode to change zx81 ROM, so part runs
or we hand over part way...)
