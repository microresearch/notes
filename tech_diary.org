* orderings

- myc/other ordering:

see mycelium_pcb_bom_.txt 

additional + for myc: pt100, pt100 breakout (ebay), light sensor??, AD5933, AD620

+ 430 ohm for temperature/MAX

+ generic power sockets and plugs 2.1mm - useful workshop bits, pi, 24vac relay for fogger control

+ for all_colours/other: 7490, light sensor for laser (BPW34), cheap multimeter, LED parts: 

led lens: Mouser VCC 593-3000R (red), 593-3000A (amber) , red/amber 5mm LED

* PI notes

** ssh

ssh and wpa must be in FIRST/boot partition!

: mount /dev/mmcblk0p1 /media  

: touch /media/ssh

** wireless network

https://raspberrypi.stackexchange.com/questions/10251/prepare-sd-card-for-wifi-on-headless-pi

/media/wpa_supplicant.conf:

ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=«your_ISO-3166-1_two-letter_country_code»

network={
    ssid="«your_SSID»"
    psk="«your_PSK»"
    key_mgmt=WPA-PSK
}

: nmap -sn 192.168.2.0/24 # to find address

** static IP/wired

In /etc/dhcpcd.conf:

interface eth0

static ip_address=192.168.1.14

static routers=10.0.0.1

static domain_name_servers=75.75.75.75 75.75.76.76 2001:558:feed::1 2001:558:feed::2

do gate add default gw blah also...

* 30/6

** steghide: 

: steghide embed -cf testfan.wav -ef ~/Downloads/latoysondorovlaf00tris_0093.jpg

: steghide extract -sf testfan.wav

Spectrograms encoder: https://github.com/solusipse/spectrology

Lots: https://github.com/DominicBreuker/stego-toolkit

* 1/7

** no titlebars/.deco in awesome:

    -- Add titlebars to normal clients and dialogs
    { rule_any = {type = { "normal", "dialog" }
      }, properties = { titlebars_enabled = false }
    },

** how z80 actually starts up

When the CPU starts running (which basically happens as soon as it
receives power and is reset with the RESET pin), it begins to pull
instructions from memory and execute them. Where it starts in memory
depends on the individual CPU, but in the case of the Z80, it simply
begins at memory address 0, instead of using a reset vector like many
other CPUs do. This means that any computer using the Z80 *must* have
a ROM chip at memory address 0 which gives the initial start-up
instructions to the Z80.

from: http://lateblt.tripod.com/z80proj1.htm

https://maker.pro/pic/projects/z80-computer-project-part-1-the-cpu

http://bedroomcoders.co.uk/using-an-arduino-to-run-a-z80/

useful: http://baltazarstudios.com/arduino-zilog-z80/

http://labs.domipheus.com/blog/teensy-z80-part-1-intro-memory-serial-io-and-display/

test circuit: http://www.z80.info/z80test0.htm

https://github.com/inxonic/z80fun

https://github.com/Apress/junk-box-arduino/blob/master/9781484214268/Z80_Explorer_v2.1/Z80_Explorer_v2.1.ino

** or 6502 or...

see emulation: http://obsolescence.wixsite.com/obsolescence/kim-uno-details

* 2/7

** Kicad BOM:

Following: https://github.com/SchrodingersGat/KiBoM

** start on parts lists and spreadsheet

Bulk

Detektors

Darkint: /root/rsync2016/darkint/hardware/draft/partslist.org

ERDs:

Misc parts/projects:

* 4/7

settings for minicom from command line

: minicom -b 57600 -D /dev/ttyACM0

* 5/7 - NEW GIT REPO!

- these notes, also messene etc. under git DONE:

add new repo in git and then in local directory of what we wish to add

: git init
: git add whatever
: git commit
: git remote add origin https://github.com/microresearch/notes.git
: git push -u origin master

- re-check AD5933 also for potential eurorack module

* 6/7

** admatech TFT display on pi:

https://raspberrypi.stackexchange.com/questions/38721/how-do-i-setup-the-c-berry-tft-screen-with-my-pi-2

and ignore row-defining changes...

for console - compile /C-Berry/SW/fb2cberry, run in background...1

: echo -ne "help" | sudo tee /dev/tty1

* 7/7

** splitscan and mencoder cut/edit

cutting using mencoder

: mencoder -ss 00:27:31 -endpos 00:00:37 -oac pcm -ovc copy Downloads/Princess.mp4 -o revolving.mp4

starts at 27.31 and lasts for 37 seconds

splitscan.py new code:

#+BEGIN_SRC python 

# horizontal

# for i in clip.iter_frames(fps=target_fps, dtype='uint8'):
#     if currentX < (clip.size[0] - slitwidth):
#         img[:,currentX:currentX + slitwidth,:] = i[:,currentX:currentX + slitwidth,:]
#     currentX += slitwidth

# horizontal/backwards
count=0
currentX = clip.size[1]

for i in clip.iter_frames(fps=target_fps, dtype='uint8'):
    print count
    if currentX < (clip.size[0] - slitwidth):
        img[:,currentX:currentX + slitwidth,:] = i[:,currentX:currentX + slitwidth,:]
    currentX -= slitwidth
    count +=1

###vertical

# for i in clip.iter_frames(fps=target_fps, dtype='uint8'):
#     if currentX < (clip.size[1] - slitwidth):
#                 img[currentX:currentX + slitwidth,:] = i[currentX:currentX + slitwidth,:]
#     currentX += slitwidth

#+END_SRC

** video to images

: ffmpeg -i input.mov -r 1 output_%04d.png

with -r 1 as 1 frame every second

** images to video

: convert output_00* test.mp4

** others

: ffmpeg -i source.mp4 -filter:v minterpolate -r 120 result.mp4


** kill cursor to end of line Ctrl - k

: bindkey

shows key bindings

* 11/7

working with imagemagick:

http://www.imagemagick.org/Usage/layers/

http://www.imagemagick.org/Usage/transform/#edge

http://www.imagemagick.org/Usage/fonts/

* 12/7

awesome

mod-t = keep window always on top

kicad

- remember after we change cvpcb netlist to generate/save netlist in eeschema

* 13/7

** teensy

https://www.pjrc.com/teensy/loader_cli.html

code: https://github.com/PaulStoffregen/teensy_loader_cli.git

: ./teensy_loader_cli -mmcu=mk20dx256 -w blink_slow_Teensy32.hex 

for our teensy 3.2 and press reset...

+using avr-gcc/example makefile: https://www.pjrc.com/teensy/gcc.html+ - this is not for ARM teensy

or we try using ard-make (had to re-install latest: https://github.com/sudar/Arduino-Makefile and latest Arduino

blink teensy example worked but not another serial example

* 16/7

*For zx81 earthboot thing on teensy (emulated ROM with earthboot)*

https://k1.spdns.de/Vintage/Sinclair/80/Sinclair%20ZX81/ROMs/zx81%20version%202%20%27improved%27%20rom%20disassembly%20%28Logan,%20O%27Hara%29.html

https://www.sinclairzxworld.com/viewtopic.php?t=1249

CS goes low for ROM access and then high within maybe 300nS

MREQ and A14 line (inverted) go through NAND to CS for this...

: // when cs goes low we put the earth code (amped from diff amp 200x in earth)
: // onto D0-> D7

As ADC is slower than 3Mhz ROM/RAM we need to read it first into array and then output

Teensy Makefile: https://github.com/apmorton/teensy-template

But we needed to change the 

: TOOLSPATH=/root/Downloads/arduino-1.8.5/hardware/tools

as the tools included are compile for 64 bits...

pins: https://forum.pjrc.com/threads/17532-Tutorial-on-digital-I-O-ATMega-PIN-PORT-DDR-D-B-registers-vs-ARM-GPIO_PDIR-_PDOR?highlight=slew+rate+limiting
          
* 17/7

zx81 3.25 MHz - 2 cycles read memory = 600 nS

https://forum.pjrc.com/threads/42865-A-set-of-scope-tested-100-500-ns-delay-macros

- display hack works - https://www.classic-computers.org.nz/blog/2016-01-03-composite-video-for-zx81.htm

- teensy is at 3.3v (no more) - some pins are not tolerant and maybe our level is low // revert to arduino/avr code  if it can be fast enough

- also after replacing ROM on zx no boot - loosen and reseat is fine (and wiggles generate glitches so...)

- code on arduino doesn't do anything (note that we would need to reboot arduino just before zx to allow buffer to fill):

-- problem could be: speed of arduino, check pins are toggling, check CS lines coming in and timing (scope)

(Notes: Uno has 2k so we just use 1024 bytes for earthcode, alt
approach could be to allow earthcode to change zx81 ROM, so part runs
or we hand over part way...)

- level shifting or protection resistor (3.3k?) or 3.3v pullup and/or check which teensy pins are 5v tolerant...

https://www.adafruit.com/product/395?gclid=CIayxrHZ4LsCFepaMgod2TwAUg

- "The other inputs (except NMI) to the Z80 are spec'd at the standard TTL levels with 2.0V or higher a logic '1'"

*when teensy=rom is selected we need to put byte on bus and then re-configure bus as input*

- for myc - new library in eeschema for 5933 created using:

http://kicad.rohrbacher.net/quicklib.php

see also: http://kicad.txplore.com/index-p=96.html

* 18/8

- some success with nS delays on Arduino:

#+BEGIN_SRC c
uint8_t earthcode[1024]; // we only have 2kb ram so we can't have 4096

void setup()  { 

  pinMode(12, INPUT_PULLUP); // CS on ROM
  pinMode(13, INPUT_PULLUP); // CS on ROM
  pinMode(A0, INPUT);

  //    DDRD = B11111111;  
  //pinMode(2, OUTPUT);

  uint16_t x;
    for (x=0;x<1024;x++){
            earthcode[x] = analogRead(A0)&0xff;
      //      earthcode[x] = rand()%0xff;
  }
} 

static __inline__ void      /* exactly 4 cycles/loop, max 2**8 loops */
_delay_loop_1_x( uint8_t __n )
{                                               /* cycles per loop      */
    __asm__ volatile (                          /* __n..one        zero */
        "1: dec  %0"   "\n\t"                   /*    1             1   */
        "   breq 2f"   "\n\t"                   /*    1             2   */
        "2: brne 1b"   "\n\t"                   /*    2             1   */
        : "=r" (__n)                            /*  -----         ----- */
        : "0" (__n)                             /*    4             4   */
    );
}


void loop()  { 
  int x=0;
  if (!(PINB & 0x10)) { // pin 12 which is on PORTB - CS on ROM
    DDRD = B11111111;  
    PORTD=earthcode[x++];
      // turn off bus - 500  ns? - value of 2 or 3 seems to work
    _delay_loop_1_x(3);
    DDRD = B00000000;  
    PORTD=0x00;
    if (x==1024) x=0;  
    }

  // test for scope
  /*  DDRD=B11111111;
  PORTD=255;
  _delay_loop_1_x(2); // this gives us 500nS
  //  delayMicroseconds(10);
  //  _delay_loop_1_x(1);
  //  DDRD = B00000000;  
  PORTD=0;
  delayMicroseconds(10);*/
}
#+END_SRC

- in Kicad/pcbnew we can draw zones after selecting layer (eg. mask) so we can leave areas exposed...

* 26/7

- find Makefile for upload of straightC code to Arduino Uno // just question of upload:

: avrdude -V -c arduino -p ATMEGA328P -P /dev/ttyACM0 -b 115200 -U flash:w:lineccd.hex

now in all_colours repo...

*TODO: collate, document makefiles for avr and coremem etc. documentation! + TEH doku...*

- serial monitor in Emacs? TEST!

: make monitor 

???

: M-x serial-term

https://www.emacswiki.org/emacs/GnuScreen#toc10

#+BEGIN_SRC lisp
(defun del-binary_characters (beg end)
  "Delete binary characters in a region"
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (while (re-search-forward "[^[:ascii:]]" nil t)
        (replace-match "")))))
#+END_SRC

* 31/7

- python script to model CPU temperature according to day's temperature changes...

#+BEGIN_SRC python
import math

# baseline - lowest temp will be base CPU temp
# read value from array of 24 hour values, run process to try to reach this if current temp is not there
# otherwise do nothing until we cool to this
# next value

# testing

x=267676383

while(1):
    x=math.sqrt(x)
#+END_SRC


- sensing CPU temp: psutil doesn't import, now using sysmon: https://github.com/calthecoder/sysmon-1.0.1

https://www.mjmwired.net/kernel/Documentation/hwmon/sysfs-interface

for pi: https://projects.raspberrypi.org/en/projects/temperature-log/4

can we increase fan speed to lower temp?

https://hackernoon.com/how-to-control-a-fan-to-cool-the-cpu-of-your-raspberrypi-3313b6e7f92c

https://raspberrypi.stackexchange.com/questions/74627/rpi-run-a-python-script-fan-speed-control-while-loop-until-shutdown

- test temp and fan thing with screen on PI!

- more finegrained temp with MAX31865 (and fix speed of arduino/MAX reading in shiftreg repo code - lost in Messene)

- Messene data dumped... all that we have

[for Messene data/temp recorded say over 24 hours we need to find max and min and re-write as values between say 0-255 limits - DONE:scaling.py]

- pi and max31865: dump temp to screen [but clash on voltage pins to fix]

https://github.com/steve71/MAX31865/blob/master/max31865.py

https://www.raspberrypi.org/documentation/usage/gpio/

CLK: 11 SDO=MISO: 9 SDI=MOSI: 10 CS: 8

Strange as ref resistor is 4301 = 4300 ohms ref rather than 430 - check others... one has 430 ohms... - 4300ohms is for PT1000 

VIN to 3.3v and SPI disabled in raspi-config

- latest KICAD from source:

: apt install cmake doxygen libboost-context-dev libboost-dev libboost-system-dev libboost-test-dev libcairo2-dev libcurl4-openssl-dev libgl1-mesa-dev libglew-dev libglm-dev liboce-foundation-dev liboce-ocaf-dev libssl-dev libwxbase3.0-dev libwxgtk3.0-dev python-dev python-wxgtk3.0-dev swig wx-common

remember to do ldconfig at end

* 2/8

- for gnuplot remember to:

: set datafile separator ","

so then we can do:

: plot "MONK27" using 0:2 with lines

without problems...

- MAX31865 code on PI gives jumpy values rather than on Arduino/adafruit but code looks very similar...

- now 31865 stopped working:

try with SPI enabled in config

try this from: http://nicke.pe.hu/max31865/rpi.html

#+BEGIN_SRC python
import spidev
from time import sleep
import math

#CONFIGURATION
Rref = 400                  # Rref = 400 for PT100, Rref = 4000 for PT1000
wire = 2                    # PT100/1000 has 2 or 3 or 4 wire connection 
#END OF CONFIGURATION

def configureMAX31865():
    lst = [0x80]
    if (wire == 2 or wire == 4):
        lst.append(0xC2)

    if (wire == 3):
        lst.append(0xD2)

    spi.writebytes(lst)

def CallendarVanDusen(R):
    a = 3.9083E-03
    b = -5.7750E-07
    R0=Rref/4

    return (-R0*a+math.sqrt(R0*R0*a*a-4*R0*b*(R0-R)))/(2*R0*b);  

spi = spidev.SpiDev()
spi.open(0,0)
spi.mode=3
lst = [0x80,0xc2]
configureMAX31865()
#spi.writebytes(lst)
sleep(0.1)

for i in range(0,6):
    reg = spi.readbytes(9)
    del reg[0]                      # delete 0th dummy data
    print ("Register values:",reg)

    RTDdata = reg[1] << 8 | reg[2]
    print("RTD data:", hex(RTDdata))

    ADCcode = RTDdata >> 1
    print("ADC code", hex(ADCcode))

    R = ADCcode * Rref / 32768
    print("Resistance:", R, "Ohms")

    print("Temperature:",round(CallendarVanDusen(R),2), "deg. C\n")
    sleep(1)
#END_SRC

* 6/8

- with PT100 ref board and older MAX31865 py/pi code we have working
  temperature measurement increasing own temp and we test with sqrt code: see pngs here...

- test sqrt to smoke / arduino code

- and cpu reflection of recorded temperature: max_temp_pi_thing.py - working but need to see how high we can get temps...

: while true; do vcgencmd measure_clock arm; vcgencmd measure_temp; sleep 10; done& stress -c 4 -t 900s

- overclocking: edit sudo nano /boot/config.txt - uncomment arm_freq=1300 # CPU Frequency 

https://howtoraspberrypi.com/how-to-overclock-raspberry-pi/

- IRF540 on GPIO pin 2 to control fan:

G-GPIO .. D=pull thru power .. -S-GND

use 2n3904 to achieve higher gate voltage EBC...

https://electronics.stackexchange.com/questions/109128/why-is-my-n-channel-mosfet-getting-very-hot-and-the-power-it-provides-to-device

note now HIGH=OFF

* 7/8

- C-c C-x f for adding footnotes in org-mode

* 8/8

- norming jacks: erthenvar PJ301BM

so without plugin lower (if we have black at top and thin pin to right from front) is connected to upper

with plugin - top is now the signal

- KiCaD - but to be tested - for hidden power on say 40106 - we put in and connect PWR_FLGs for both VCC/12V and GND lines

- A computer processor is coerced into attempting to match its
  external temperature to the temperature recorded at high resolution
  within a pile of stones in Ancient Messene across 24 hours. The attempt
  last longer than 24 hours.

- GPU mining to achieve a recorded temperature. both temperature and earnings are expressed in smoke

* 13/8

- more temperature work on pi:

: nohup sysbench --num-threads=8 --test=cpu --cpu-max-prime=10000000000 run &
: watch sudo cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq

shows that we are overclocked according to: 

https://www.reddit.com/r/raspberry_pi/comments/48lhot/raspberry_pi_family_thermal_analysis_thermal/

and freezes our ssh session...

- now we resume temperature mime study with internal sensor which according to page above is:

One possible explanation for this is that the temperature sensor is
located in the VideoCore-IV portion of the silicon, while I'm loading
the Cortex-A53 portion. You can see this in the close-up shot at the
end of the album: the top of the SoC is far hotter than the
bottom. You can also see that the CPU portion of the SoC is running
out of spec: its official operating temperature limit is 85°C, and the
close-up reads over 100°C peak.

- last (5 days running) graph is:

final_temp1308.png

- overclocking to 130MHz causes crashes so now reverted...
